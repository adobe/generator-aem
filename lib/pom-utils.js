
import path from 'node:path';

import { XMLParser } from 'fast-xml-parser';
import _ from 'lodash';

const xmlOptions = Object.freeze({
  preserveOrder: true,
  format: true,
  ignoreAttributes: false,
  commentPropName: '#comment',
  numberParseOptions: {
    skipLike: /\d+.\d+/,
  },
});

/**
 * Parses the pom from the specified directory.
 *
 * @returns the parsed pom data
 */
const readPom = (generator) => {
  const pom = generator.destinationPath('pom.xml');
  if (!generator.fs.exists(pom)) {
    return {};
  }

  const data = generator.fs.read(pom);
  const parser = new XMLParser(xmlOptions);
  return parser.parse(data);
};


const findPomNodeArray = (wrapper, ...names) => {
  let name = names.pop();
  if (names.length !== 0) {
    wrapper = findPomNodeArray(wrapper, ...names);
  }
  const found = _.find(wrapper, (item) => _.has(item, name));
  if (!found) {
    return found;
  }
  return found[name];
};


/**
 * Fixes XML string to remove returns between text elements; mostly to make Poms look "normal"
 * @param xml the xml to fix
 * @returns {String} the fixed xml
 * @private
 */
const fixXml = (xml) => {
  // XML generated by library splits text into multi line, this removes those and fixes file formatting.
  return xml.replace(/(<[a-zA-Z\d.]+>)\s*\n\s*([^<]+)\s*\n\s*(<\/[a-zA-Z\d.]+>)/g, '$1$2$3');
};

const propertyPredicate = (target, property) => {
  return _.find(target, (item) => {
    return _.has(item, Object.keys(property)[0]);
  });
}

const pluginPredicate = (target, plugin) => {
  if (!plugin.plugin) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }
  const groupId = PomUtils.findPomNodeArray(plugin.plugin, 'groupId')[0]['#text'];
  const artifactId = PomUtils.findPomNodeArray(plugin.plugin, 'artifactId')[0]['#text'];

  return _.find(target, (item) => {
    const findGroupId = PomUtils.findPomNodeArray(item.plugin, 'groupId');
    const findArtifactId = PomUtils.findPomNodeArray(item.plugin, 'artifactId');

    return artifactId === findArtifactId[0]['#text'] && (findGroupId === undefined || groupId === findGroupId[0]['#text']);
  });
}

const dependencyPredicate = (target, dependency) => {
  if (!dependency.dependency) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }
  const groupId = PomUtils.findPomNodeArray(dependency.dependency, 'groupId')[0]['#text'];
  const artifactId = PomUtils.findPomNodeArray(dependency.dependency, 'artifactId')[0]['#text'];

  return _.find(target, (item) => {
    const findGroupId = PomUtils.findPomNodeArray(item.dependency, 'groupId');
    const findArtifactId = PomUtils.findPomNodeArray(item.dependency, 'artifactId');

    return groupId === findGroupId[0]['#text'] && artifactId === findArtifactId[0]['#text'];
  });
}

const profilePredicate = (target, profile) => {
  if (!profile.profile) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }

  const id = PomUtils.findPomNodeArray(profile.profile, 'id')[0]['#text'];

  return _.find(target, (item) => {
    return id === PomUtils.findPomNodeArray(item.profile, 'id')[0]['#text'];
  });
}

const mergePomSection = (target, additional, predicate = _.deepEqual) => {
  _.remove(additional, (item) => {
    return predicate(target, item);
  });
  target.push(...additional);
};

const PomUtils = {
  xmlOptions,
  readPom,
  fixXml,
  findPomNodeArray,
  propertyPredicate,
  pluginPredicate,
  dependencyPredicate,
  profilePredicate,
  mergePomSection,
}

export default PomUtils;
