import _ from 'lodash';

import { XMLParser } from 'fast-xml-parser';

const xmlOptions = Object.freeze({
  preserveOrder: true,
  format: true,
  ignoreAttributes: false,
  commentPropName: '#comment',
  numberParseOptions: {
    skipLike: /\d+.\d+/,
  },
});

/**
 * Parses the pom from the specified directory.
 *
 * @param {Generator} generator the generator context
 * @returns {{}|Object} the pom contents
 */
const readPom = (generator) => {
  const pom = generator.destinationPath('pom.xml');
  if (!generator.fs.exists(pom)) {
    return {};
  }

  const data = generator.fs.read(pom);
  const parser = new XMLParser(xmlOptions);
  return parser.parse(data);
};

/**
 * Finds the specific node within a parsed pom.
 *
 * @param wrapper the wrapper context
 * @param names list of names to traverse to
 * @returns {undefined|Array} the found Array or undefined
 */
const findPomNodeArray = (wrapper, ...names) => {
  let name = names.pop();
  if (names.length !== 0) {
    wrapper = findPomNodeArray(wrapper, ...names);
  }
  const found = _.find(wrapper, (item) => _.has(item, name));
  if (!found) {
    return found;
  }
  return found[name];
};

/**
 * Fixes XML string to remove returns between text elements; mostly to make Poms look "normal"
 * @param xml the xml to fix
 * @returns {String} the fixed xml
 */
const fixXml = (xml) => {
  // XML generated by library splits text into multi line, this removes those and fixes file formatting.
  return xml.replace(/(<[a-zA-Z\d.]+>)\s*\n\s*([^<]+)\s*\n\s*(<\/[a-zA-Z\d.]+>)/g, '$1$2$3');
};

/**
 * Predicate for matching a Pom Property struct against a list of properties.
 *
 * Value of the property is ignored, if the name exists in the target, it is considered "found".
 *
 * @param target the list to search
 * @param property the property to find
 * @returns {boolean} if that property was found
 */
const propertyPredicate = (target, property) => {
  return _.find(target, (item) => {
    return _.has(item, Object.keys(property)[0]);
  });
}

/**
 * Predicate for matching a Pom Plugin struct against a specific a list of plugins.
 *
 * Only the GroupId and ArtifactId are used to make a match, version and other details are ignored.
 * If either plugin doesn't have a GroupId specified, it is ignored for matching purposes.
 *
 * @param target the list to search
 * @param plugin the plugin to find
 * @returns {boolean} if the plugin was found, or it wasn't a plugin struct
 */
const pluginPredicate = (target, plugin) => {
  if (!plugin.plugin) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }

  // Plugins dont have to use a groupId... so if either is not provided, assume truth based strictly on artifactId
  const groupId = PomUtils.findPomNodeArray(plugin.plugin, 'groupId');
  const artifactId = PomUtils.findPomNodeArray(plugin.plugin, 'artifactId')[0]['#text'];

  return _.find(target, (item) => {
    const findGroupId = PomUtils.findPomNodeArray(item.plugin, 'groupId');
    const findArtifactId = PomUtils.findPomNodeArray(item.plugin, 'artifactId');

    return artifactId === findArtifactId[0]['#text'] &&
      (findGroupId === undefined || groupId === undefined || groupId[0]['#text'] === findGroupId[0]['#text']);
  });
}

/**
 * Predicate for matching a Pom Dependency struct against a specific a list of dependencies.
 *
 * Only the GroupId and ArtifactId are used to make a match, version and other details are ignored.
 *
 * @param target the list to search
 * @param dependency the dependency to find
 * @returns {boolean} if the dependency was found, or it wasn't a dependency struct
 */
const dependencyPredicate = (target, dependency) => {
  if (!dependency.dependency) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }
  const groupId = PomUtils.findPomNodeArray(dependency.dependency, 'groupId')[0]['#text'];
  const artifactId = PomUtils.findPomNodeArray(dependency.dependency, 'artifactId')[0]['#text'];

  return _.find(target, (item) => {
    const findGroupId = PomUtils.findPomNodeArray(item.dependency, 'groupId');
    const findArtifactId = PomUtils.findPomNodeArray(item.dependency, 'artifactId');

    return groupId === findGroupId[0]['#text'] && artifactId === findArtifactId[0]['#text'];
  });
}

/**
 * Predicate for matching a Pom Profile struct against a specific a list of profiles.
 *
 * Only the id of the profile is used to match.
 *
 * @param target the list to search
 * @param profile the profile to find
 * @returns {boolean} if the profile was found, or it wasn't a profile struct
 */
const profilePredicate = (target, profile) => {
  if (!profile.profile) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }

  const id = PomUtils.findPomNodeArray(profile.profile, 'id')[0]['#text'];

  return _.find(target, (item) => {
    return id === PomUtils.findPomNodeArray(item.profile, 'id')[0]['#text'];
  });
}

/**
 * Merges two pom structures into one.
 *
 * The additional items list will be added to the end of the target, if they do not already exist.
 *
 * Existence is determined by the predicate. If it returns true, then the item in the additional list will be ignored.
 * The predicate Parameters are the `target` list, and each item in the additional list.
 *
 * @param target the list to add items
 * @param additional the items to add
 * @param predicate function to determine duplicates
 */
const mergePomSection = (target, additional, predicate) => {
  _.remove(additional, (item) => {
    return predicate(target, item);
  });
  target.push(...additional);
};

const PomUtils = {
  xmlOptions,
  readPom,
  fixXml,
  findPomNodeArray,
  propertyPredicate,
  pluginPredicate,
  dependencyPredicate,
  profilePredicate,
  mergePomSection,
}

export default PomUtils;
