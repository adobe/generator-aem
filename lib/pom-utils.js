/*
 Copyright 2022 Adobe Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

import path from 'node:path';
import _ from 'lodash';

import { XMLBuilder, XMLParser } from 'fast-xml-parser';

const xmlOptions = Object.freeze({
  preserveOrder: true,
  format: true,
  ignoreAttributes: false,
  commentPropName: '#comment',
  numberParseOptions: {
    skipLike: /\d+.\d+/,
  },
});

export const filevaultPlugin = 'filevault-package-maven-plugin';

/**
 * Parses the pom from Generator's root directory.
 *
 * @param {Generator} generator the generator context
 * @return {{}|Object} the pom contents
 */
const readPom = (generator) => {
  const pom = generator.destinationPath('pom.xml');
  if (!generator.fs.exists(pom)) {
    return {};
  }

  const data = generator.fs.read(pom);
  const parser = new XMLParser(xmlOptions);
  return parser.parse(data);
};

/**
 * List the module paths in the generator's parent pom
 *
 * @param {Generator} generator the generator context
 * @param rootPath the root path to the parent pom context
 * @return {[]|Array} list of modules or an empty list
 */
const listParentPomModules = (generator, rootPath) => {
  if (!generator.fs.exists(path.join(rootPath, 'pom.xml'))) {
    return [];
  }

  const pom = new XMLParser().parse(generator.fs.read(path.join(rootPath, 'pom.xml')));
  if (!pom.project.modules || !pom.project.modules.module) {
    return [];
  }

  return Array.isArray(pom.project.modules.module) ? pom.project.modules.module : [pom.project.modules.module];
};

/**
 * Finds the specific node within a parsed pom.
 *
 * @param wrapper the wrapper context
 * @param names list of names to traverse to
 * @return {undefined|Array} the found Array or undefined
 */
const findPomNodeArray = (wrapper, ...names) => {
  const name = names.pop();
  if (names.length > 0) {
    wrapper = findPomNodeArray(wrapper, ...names);
  }

  const found = _.find(wrapper, (item) => _.has(item, name));
  if (!found) {
    return found;
  }

  return found[name];
};

/**
 * Fixes XML string to remove returns between text elements; mostly to make Poms look "normal"
 * @param xml the xml to fix
 * @return {String} the fixed xml
 */
const fixXml = (xml) => {
  // XML generated by library splits text into multi line, this removes those and fixes file formatting.
  return xml.replace(/(<[a-zA-Z\d.]+>)\s*\n\s*([^<]+)\s*\n\s*(<\/[a-zA-Z\d.]+>)/g, '$1$2$3');
};

/**
 * Predicate for matching a Pom Property struct against a list of properties.
 *
 * Value of the property is ignored, if the name exists in the target, it is considered "found".
 *
 * @param target the list to search
 * @param property the property to find
 * @return {boolean} if that property was found
 */
const propertyPredicate = (target, property) => {
  return _.find(target, (item) => {
    return _.has(item, Object.keys(property)[0]);
  });
};

/**
 * Predicate for matching a Pom Plugin struct against a specific a list of plugins.
 *
 * Only the GroupId and ArtifactId are used to make a match, version and other details are ignored.
 * If either plugin doesn't have a GroupId specified, it is ignored for matching purposes.
 *
 * @param target the list to search
 * @param plugin the plugin to find
 * @return {boolean} if the plugin was found, or it wasn't a plugin struct
 */
const pluginPredicate = (target, plugin) => {
  if (!plugin.plugin) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }

  // Plugins dont have to use a groupId... so if either is not provided, assume truth based strictly on artifactId
  const groupId = PomUtils.findPomNodeArray(plugin.plugin, 'groupId');
  const artifactId = PomUtils.findPomNodeArray(plugin.plugin, 'artifactId')[0]['#text'];

  return _.find(target, (item) => {
    if (!item.plugin) {
      return false;
    }

    const findGroupId = PomUtils.findPomNodeArray(item.plugin, 'groupId');
    const findArtifactId = PomUtils.findPomNodeArray(item.plugin, 'artifactId');

    return artifactId === findArtifactId[0]['#text'] && (findGroupId === undefined || groupId === undefined || groupId[0]['#text'] === findGroupId[0]['#text']);
  });
};

/**
 * Predicate for matching a Pom Dependency struct against a specific a list of dependencies.
 *
 * Only the GroupId and ArtifactId are used to make a match, version and other details are ignored.
 *
 * @param target the list to search
 * @param dependency the dependency to find
 * @return {boolean} if the dependency was found, or it wasn't a dependency struct
 */
const dependencyPredicate = (target, dependency) => {
  if (!dependency.dependency) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }

  const groupId = PomUtils.findPomNodeArray(dependency.dependency, 'groupId')[0]['#text'];
  const artifactId = PomUtils.findPomNodeArray(dependency.dependency, 'artifactId')[0]['#text'];

  return _.find(target, (item) => {
    if (!item.dependency) {
      return false;
    }

    const findGroupId = PomUtils.findPomNodeArray(item.dependency, 'groupId');
    const findArtifactId = PomUtils.findPomNodeArray(item.dependency, 'artifactId');

    return groupId === findGroupId[0]['#text'] && artifactId === findArtifactId[0]['#text'];
  });
};

/**
 * Predicate for matching a Pom Profile struct against a specific a list of profiles.
 *
 * Only the id of the profile is used to match.
 *
 * @param target the list to search
 * @param profile the profile to find
 * @return {boolean} if the profile was found, or it wasn't a profile struct
 */
const profilePredicate = (target, profile) => {
  if (!profile.profile) {
    // If it's a comment, just leave it - best we can do. Though may create some duplicate info.
    return false;
  }

  const id = PomUtils.findPomNodeArray(profile.profile, 'id')[0]['#text'];

  return _.find(target, (item) => {
    return id === PomUtils.findPomNodeArray(item.profile, 'id')[0]['#text'];
  });
};

/**
 * Merges two pom structures into one.
 *
 * The additional items list will be added to the end of the target, if they do not already exist.
 *
 * Existence is determined by the predicate. If it returns true, then the item in the additional list will be ignored.
 * The predicate Parameters are the `target` list, and each item in the additional list.
 *
 * @param target the list to add items
 * @param additional the items to add
 * @param predicate function to determine duplicates
 */
const mergePomSection = (target, additional, predicate) => {
  if (!additional) {
    return;
  }

  _.remove(additional, (item) => {
    return predicate(target, item);
  });
  target.push(...additional);
};

/**
 * Removes the specified dependencies from the provided list, referenced by target.
 *
 * @param target the list from which to remove dependencies
 * @param dependencies the dependencies to remove.
 */
const removeDependencies = (target, dependencies) => {
  _.remove(target, (item) => {
    return PomUtils.dependencyPredicate(dependencies, item);
  });
};

/**
 * Add the list of dependencies to the target list. If after is provided, that they will be inserted in the referenced artifact.
 *
 * `after` should be an object:
 *   {
 *     groupId: 'The GroupId to Match',
 *     artifactId: 'The Artifact Id to Match'
 *   }
 *
 * @param target the list to which to add dependencies
 * @param dependencies the dependencies to add
 * @param after the location in the list after which to add the dependencies
 */
const addDependencies = (target, dependencies, after) => {
  let insertAt = target.length;
  if (after) {
    // Find index to insert at
    insertAt = _.findIndex(target, (dep) => {
      const groupId = PomUtils.findPomNodeArray(dep.dependency, 'groupId');
      const artifactId = PomUtils.findPomNodeArray(dep.dependency, 'artifactId');
      if (!groupId || !artifactId) {
        return false; // Comments.
      }

      return groupId[0]['#text'] === after.groupId && artifactId[0]['#text'] === after.artifactId;
    });
    if (insertAt === -1) {
      insertAt = target.length;
    } else {
      insertAt += 1;
    }
  }

  target.splice(insertAt, 0, ...dependencies);
};

/**
 * Adds the current module to the Parent Pom module list.
 *
 * @private
 */
const addModuleToParent = (generator) => {
  const parentPom = path.join(path.dirname(generator.destinationRoot()), 'pom.xml');
  const data = generator.fs.read(parentPom);
  const parsed = new XMLParser(xmlOptions).parse(data);

  const project = findPomNodeArray(parsed, 'project');
  let modules = findPomNodeArray(project, 'modules');

  if (!modules) {
    let insertAfter = 0;
    _.each(['artifactId', 'name', 'description'], (element) => {
      _.each(project, (value, idx) => {
        if (_.has(value, element)) {
          insertAfter = idx;
          return false;
        }
      });
    });
    modules = [];
    project.splice(insertAfter + 1, 0, { modules });
  }

  const toAdd = { module: [{ '#text': path.basename(generator.destinationRoot()) }] };

  let found = false;
  _.each(modules, (mod) => {
    found = _.isEqual(mod, toAdd);
    if (found) {
      return false;
    }
  });
  if (!found) {
    modules.push(toAdd);
  }

  generator.fs.write(parentPom, fixXml(new XMLBuilder(xmlOptions).build(parsed)));
};

const PomUtils = {
  xmlOptions,
  readPom,
  listParentPomModules,
  fixXml,
  findPomNodeArray,
  propertyPredicate,
  pluginPredicate,
  dependencyPredicate,
  profilePredicate,
  mergePomSection,
  addModuleToParent,
  removeDependencies,
  addDependencies,
};

export default PomUtils;
